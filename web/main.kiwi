[index
  [p Here you can find a series of short tutorials (called 'bites') on the basic elements of the Fruity programming language. Fruity is kinda like the three-way bastard child of Forth, APL, and the weird bits of JavaScript, so unless you are familiar with all three languages already, reading through these from the beginning is recommended. Hell, even if you are familiar with all three, you'd surely realise how asinine that sounds and that you should probably read these from the beginning anyway.]
  [p Each bite will give an explaination of the concept, with examples. At the end of each bite is a challenge, with an example solution.]
]

[bite Values
  [p After installation, you can execute Fruity code either in the REPL, or by loading it from a file. Most of these tutorials expect you to be using the REPL, which you can launch with the command [mono fp]]
  [p Fruity has several types of values you can manipulate. The first we will cover is the number. You can type a number into the REPL and you will get that number back.]
  [repl
  24
  -3.5
  3e9
  ]
  [p Another type is strings, much like you would expect from any other language. These always use single quotation marks.]
  [repl
  'hello world'
  'two\nlines'
  ]
  [p Another type is symbols. These start with a hash followed by an identifier, which is a series of alphanumeric characters and underscores, but may not start with a digit.]
  [repl
  #kai
  #_Fish9
  ]
  [p One last type is the oddball. We won't see these much until later, but there are precisely 4 of these.]
  [repl
  true false default nil
  ]
  [p When we type in a value like this, the action we're doing is called 'pushing'. We can push multiple values by separating them with spaces.]
  [repl
  'Jason' 6 5
  #May 23
  ]
  [p All these values together are called the stack. The most recently pushed value is on the right, and is known as the top. The metaphor here is based on a stack of cards. You can only place ('push') a new card on top. Fruity programs consist of a series of operations on this stack, evaluated from left to right.]
]

[challenge You Push Me Right Round...
  [p For this challenge, you must replicate the following output:]
  [repl _USER_: {1 #two 'tree' 4}
  _USER_
  ]
  [p Below is an answer box, clicking on 'Answer' will show you a solution to the challenge. It will also explain how the solution works in detail. Usually there are multiple valid solutions to a challenge, comparing your solution with the provided answer may provide you with new insights.]
  [answer
  [p Just type in the output. In Fruity, most output can be reproduced just by typing it in. Note that basically every challenge after this explicitly forbids you from just typing in the output otherwise it wouldn't be much of a challenge...]
  [repl
  1 #two 'tree' 4
  ]
  [p Going through in order of execution, the code [code 1] pushes 1, the code [code #two] pushes [code #two], and so on until we finally have [code 1 #two 'tree' 4]]
  ]
]

[bite Stack Manipulation I
  [p Simply typing in the output you desire isn't particularly useful, so Fruity programs are generally comprised of functions that manipulate the stack in various ways. In this bite we will cover some of the most basic ones for rearranging values on the stack.]
  [p The [code dup] function (short for duplicate) will push a copy of the top value.]
  [repl
  3 dup
  'Jason' 'Mary' 'Anne' dup
  1 2 dup 3
  ]
  [p What's the reverse of pushing? Popping! The [code pop] function will remove the last value from the stack.]
  [repl
  'Goodbye' 'Jason' pop
  1 2 3 pop 4 5
  ]
  [p Another useful function is [code swap], which changes the order of the top two values.]
  [repl
  'First' 'Last' swap
  1 2 3 swap
  1 2 3 swap 4
  ]
  [p The [code top] function removes all but the top value.]
  [repl
  1 2 3 top
  1 2 swap top
  ]
  [p Note in the previous example, [code swap] changes the stack to [code 2 1], so when [code top] is executed, [code 1] will be the value on top instead.]
  [p Finally, the [code clear] function removes all values. This one is slightly less useful than the others, but comes up occasionally.]
  [repl
  #a #b #c clear
  1 2 clear 3
  ]
]

[challenge Mixin' it up!
  [p Write some code to transform the stack [code 1 2 'Jason' 3] into the result [code 1 3 2 2]]
  [p You should not push anything, other than the [code 1 2 'Jason' 3] at the beginning.]
  [repl _USER_: {swap pop swap dup}
  1 2 'Jason' 3 _USER_
  ]
  [p Note: To test out your code, you will have to include [code 1 2 'Jason' 3] first each time. Pressing the up key in the repl will let you edit your previous line so you don't have to type this more than necessary.]
  [answer
  [repl
  1 2 'Jason' 3 swap pop swap dup
  ]
  [p First we [code swap] the first two values to get [code 1 2 3 'Jason'], and then use [code pop] to remove 'Jason' from the stack. We then use [code swap] to make the stack into [code 1 3 2], and then use [code dup] to duplicate the 2 on the end.]
  ]
]

[bite Stack Manipulation II
  [p If [code swap] wasn't exciting enough for you, we can use the [code reverse] function to reverse all of values on the stack.]
  [repl
  'LIFT OFF' 1 2 3 reverse
  ]
  [p We can bring the bottom value of the stack to the top using the [code under] function.]
  [repl
  1 2 3 under
  ]
  [p Finally, we can order all values on the stack using the [code sort] function. If values of multiple differing types are on the stack, they will be ordered by type (numbers, then symbols, then strings).]
  [repl
  3 1 2 0 sort
  'apple' 'orange' 'lemon' 'lime' 'banana' sort
  1 'Apple Juice' 2 #orange 'Milk' sort
  ]
]

[challenge Will it Blend?
  [p This challenge is the same as the last - write something to convert what you're given into the shown output.]
  [repl _USER_: {under dup under pop sort}
  1 'Jason' 3 4 _USER_
  ]
  [p Again, you should not push any additional values.]
  [p There are many possible solutions to this challenge.]
  [answer
  [p Here are some possible solutions.]
  [repl
  1 'Jason' 3 4 sort pop reverse dup reverse
  1 'Jason' 3 4 under dup under pop sort
  1 'Jason' 3 4 reverse swap pop dup reverse
  ]
  [p In the first solution, [code sort] is used first to bring [code 'Jason'] to the top of the stack, which is then removed by [code pop]. [code reverse] then brings [code 1] to the front, which we duplicate with [code dup] before returning the stack to it's original order using [code reverse].]
  ]
]

[bite Arithmetic
  [p Calculations can be performed using the numerous mathematical functions in Fruity.]
  [repl
  1 2 add
  10 1 sub
  3 4 mul
  7 2 div
  ]
  [p Each of these functions will take the last two values and perform the corresponding action - addition, subtraction, multiplication, and division.]
  [p There are several more mathematical functions built in:]
  [repl
  10 4 mod
  2 4 pow
  -3 abs
  16 9 divmod
  ]
  [p These calculate modulo, power, and absolute value respectively. The [code divmod] function is unique in that it returns two values, the first is the result of integer division and the second is the remainder. In more mathematical terms, if [code a b divmod = c d] then the terms are related by [code c * b + d = a].]
  [p They can be combined together like any other functions.]
  [repl
  1 2 add 3 add
  3 4 mul 1 sub 3 mul
  4 2 add 3 1 sub div
  ]
  [p Work through these step by step to make sure you understand how they arrive at their answers. This way of writing formulas is known as Reverse Polish Notation, or Postfix. There's lots of great resources online for understanding this notation if you find it confusing.]
  [p One of the neat features of postfix notation is that parentheses are no longer necessary, it is unambiguous which values are parts of which operation.]
]

[challenge Formulatin' Formulas!
  [p Convert the following formula into Fruity code using the functions we just covered.]
  [repl
  11 / (6 * 3 - 2)
  ]
  [answer
  [repl
  11 6 3 mul 2 sub div
  ]
  [p This one is pretty straighforward if you understand postfix notation. First [code mul] will multiply the 6 and 3, [code sub] will subtract 2 from the result of [code mul], and finally with [code div] 11 will be divided by the result of [code sub].]
  ]
]

[bite Functions I
  [p In Fruity, we can define our own custom functions with the following syntax:]
  [repl
    myfun: {0 swap sub}
  ]
  [p The above function negates a given value. In fact, there is already a standard function that does this: [code negate]. We can place any code we like between the braces, and typing the functions name will be equivalent to having typed out it's code in place of it.]
  [repl
    23 myfun
    23 0 swap sub
  ]
  [p Unlike simple substitution recursion is possible, but we haven't covered conditional execution so please don't try it yet! Additionally, there are some minor differences which we will cover when we get there.]
  [p We can even define functions within functions if we really want. These functions will only be accessible from within the function they are defined.]
  [repl
    quadruple: {double: {dup add} double double}
  ]
]

[challenge Measuring Hypopotamuses
  [p Write a function [code square] that calculates the square of a given value. Then, write a function [code hypo] that calculates length of a the hypotenuse given the two other sides (i.e. calculate c with pythagoreas' theorem), using the [code square] function you wrote.]
  [repl square: {dup mul} dist: {}
    7 square
    3 4 dist
    5 12 dist
  ]
  [hint [code pow] can be used for square roots.]
  [answer
    [repl
    square: {dup mul}
    dist: {square swap square add 0.5 pow}
    7 square
    3 4 dist
    5 12 dist
    ]
    [p For [code square], we duplicate the top of the stack and then multiply them together, squaring the value.]
    [p For [code dist], we [code square] the top two values of the stack, [code add] them together, and then raise to the power of a half to calculate the square root.]
  ]
]

[bite Grouping
  [p Earlier we saw how postfix allows us to evaluate mathematical expressions like [code 1 - (2 + 3) * 4] without needing parentheses or worrying about BODMAS (or was it PEMDAS?).]
  [repl
  1 2 3 add 4 mul sub
  ]
  [p Well, Fruity does still allow us to use parentheses, to create what are called groups. The above could be rewritten as:]
  [repl
  (1 ((2 3 add) 4 mul) sub)
  ]
  [p Lisp programmers be like 🤔 right about now...]
  [p A group is evaluated on it's own stack, independently of the rest of the groups. At the end of it's execution (i.e. once we reach the closing parenthesis) it will push anything left on it's stack onto the previous stack. The above code works because each group will evaluate to a single result, which will then be pushed in the groups place onto the previous stack.]
  [p Note that Fruity's syntax is rather whitespace sensitive, and usually requires a whitespace between every token. The one exception to this is on the inside of parentheses and braces (which we'll see later). Spaces are still required on the outside of braces, so while [code 1 (2)] is okay, [mono 1(2)] is not.]
  [p To get a better idea of how execution works, we can 'inspect' the stack within a group:]
  [repl
  #a (#b #c dump)
  ]
  [p Here I've used a new function, [code dump]. This function will print out a representation of the current stack for debugging purposes. Because it is executed within the group, it is only able to see [code #b] and [code #c], and so that it all it prints.]
  [p Similarly, we can use the [code size] function to count how many values are on the current stack:]
  [repl
  #a (#b #c size)
  ]
  [p You might be wondering what the point of all this is, and indeed we haven't seen anything useful so far. So, let's try out the [code math.sum] function.]
  [repl
  6 (1 2 3 4 math.sum) mul
  ]
  [p This function takes all values on the stack and returns the sum of them. This is much like a variadic function in other languages, as it can take any amount of arguments. The use of a group here allows us to execute it in isolation from the rest of the program - in this case, making sure it doesn't include the [code 6] we push at the start.]
  [p The [code reverse] and [code sort] functions we saw earlier are much the same, as they manipulate the entire stack, but can be restricted by the use of groups.]
  [repl
  (3 1 2 sort) ('apple' 'coconut' 'banan' reverse)
  ]
]

[challenge Minmaxing
  [p Here's code to define a function called [code nums] which pushes [code 5 3 9 7] to the stack. Copy paste this line into the REPL to define the function.]
  [repl
  nums: {5 3 9 7}
  ]
  [p Write a single line of code that, using [code nums], finds the minimum and maximum value the function pushes. It should work even if you change the numbers pushed by [code nums].]
  [repl _USER_: {(nums sort reverse top) (nums sort top)}
  _USER_
  ]
  [hint Finding either the minimum or maximum can be done just using the functions we've seen so far.]
  [answer
  [p We can use [code sort reverse top] to find the minimum, and [code sort top] to find the maximum.]
  [repl
  nums sort reverse top (nums sort top)
  ]
  [p The second part must be in a group, otherwise the earlier found minimum would be removed by the second [code top].]
  [repl
  nums sort reverse top nums sort top
  ]
  [p You could make these into functions if you really wanted to. Most of these challenges don't really need you to define functions though, so you won't see this again for a while.]
  [repl
  min: {sort reverse top}
  max: {sort top}
  nums min (nums max)
  ]
  ]
]

[bite Dots
  [p As you may have figured out by now, Fruity's main data structure is not just a stack, but a stack of stacks*. Each time we enter a group, a new stack is pushed to the stack-stack, and when we exit a group the top stack is popped from the stack-stack, with it's contents put on the end of the new top stack.]
  [hint *Actually, it's a stack of stacks of stacks... Just kidding... Unless?]
  [p So, if we can manipulate the (regular) stack in all sorts of ways, can we do the same with the stack-stack? Well, not quite. But there is one operator that can communicate between stacks, the dot operator.]
  [p The dot operator allows us to move values from the previous stack to the current (top) stack. As an example:]
  [repl
  1 2 (. 3 math.sum)
  ]
  [p In the above example, the [code .] moved the 2 from the previous stack to the top stack, and so it was then included in the calculation of [code math.sum].]
  [p We can move multiple values at once using several dots:]
  [repl
  1 2 3 4 (.. dump)
  1 2 3 4 (... dump)
  ]
  [p Interestingly, note how order is preserved. Multiple dots like this are considered as a single operation. If we separate them with spaces, they will be treated as separate operations and done in order:]
  [repl
  1 2 3 4 (. . dump)
  1 2 3 4 (. . . dump)
  ]
  [p Notice how this version had the effect of reversing the values. Moving them all at once preserves order, while moving them one at a time reverses them (consider moving cards one at a time to a new stack vs all at once to get a more intuitive sense for why this is). We can combine both for more interesting reorderings of the stack:]
  [repl
  1 2 3 4 (.. . .)
  ]
  [p This is one of those things that's exceedingly neat, but in practice I barely use the dot operator much beyond one or two values. Reality is depressing...]
]

[challenge Morse Code
  [p Reorganise the following values into the desired output using only groups and the dot operator:]
  [repl _USER_: {(. .. .) (. . . .)}
  1 2 #apple #banan _USER_
  ]
  [answer
  [repl
  1 2 #apple #banan (. .. .) (. . . .)
  ]
  [p The first group will rearrange the stack into [code #banan 2 #apple 1], which is the desired output but backwards. Then, we the second group will just reverse that to give us the desired output (in reality, you'd normally use the [code reverse] function here)]
  ]
]

[bite String Operations
  [p Fruity has various functions for operating on strings. The [code str] function converts any value into a string.]
  [repl
  32 str #a str 'Hello' str
  ]
  [p The [code rep] function is almost identical, however it will attempt to provide a source-code like representation of the value. For strings, this means including quotation marks and escaping characters.]
  [repl
  32 rep #a rep 'Hello\nworld' rep
  ]
  [p Note the string above looks extra confusing as it is essentially being [code rep]'d twice, once when we call [code rep] and another time by the REPL to display the output.]
  [p There are also the [code int] and [code float] functions, for converting a string to a number. The [code int] function will only accept integers. [code int] can also be used to round a number to the nearest integer.]
  [repl
  '32' int
  '3.14' float
  3.14 int
  ]
  [p The [code open] function can be used to break a string into individual characters.]
  [repl
  'Hello' open
  ]
  [p The [code cat] function will combine everything on the stack into one string. Each value is converted to a string using [code str] internally.]
  [repl
  'Who' 'Is' 'Juan' '?' cat
  '1 + 1 = ' 2 cat
  1 2 3 cat
  ]
  [p The [code char] function behaves like [code open], but returns ASCII values instead.]
  [repl
  'fish' char
  ]
  [p And finally the [code mkstr] function is the inverse of [code char], making a string from ASCII values on the stack.]
  [repl
  121 101 101 104 97 119 mkstr
  'fish' char mkstr
  ]
  [p The [code char] function will also convert a single ASCII value into a string. Unlike [code mkstr] though it will only manipulate the top value.]
  [repl
  42 char
  98 99 100 char
  ]
]

[challenge sdrawkcab
  [p Write a program that reverses whatever string it is given. For example:]
  [repl _USER_: {open reverse cat}
  'hello' _USER_
  'omae wa mou' _USER_
  ]
  [answer
  [p Either open/cat or char/mkstr can be used here. open/cat is preferable as those are more commonly used functions.]
  [repl
  'hello' open reverse cat
  'hello' char reverse mkstr
  ]
  [p First we split the string into it's individual characters, we use [code reverse] to reverse their order, and then we recombine them back into a single string.]
  ]
]

[bite Console IO
  [p We can display strings to the user using the [code print] function.]
  [repl
  'This text was printed.' print
  'This one too.' print
  ]
  [p The [code print] function inserts a new line afterwards, so each time it is called it will print onto a new line.]
  [repl
  'a' print 'b' print 'c' print
  ]
  [p The [code printw] function does not insert a new line, allowing us to print onto the same line.]
  [repl
  'a' printw 'b' printw 'c' print
  ]
  [p We can also get a string as input from the user.]
  [repl
  input printw ' is a cool kid.' print
  Jason
  ]
  [p If we need to get a number from the user, we can convert it using [code float] or [code int].]
  [repl
  input int 1 add ' is a bigger number!' cat print
  6
  ]
  [p Since we often want to print out some kind of prompt to ask the user to type input, we also have the [code prompt] function which does just that.]
  [repl
  'let x = ' prompt int dup dup mul mul 'x^3 = ' swap cat print
  4
  ]
]

[challenge Hi, Ny Name is...
  [p Write a program that asks a user for their name, then prints a personalized greeting.]
  [repl _USER_: {'Enter your name: ' prompt 'Hello, ' printw print}
  _USER_
  Jason
  _USER_
  Mary
  ]
  [answer
  [repl
  'Enter your name: ' prompt 'Hello, ' printw print
  Jason
  ]
  [p First we use [code 'Enter your name:' prompt] to display the message and get the user's input.]
  [p [code 'Hello, ' printw] will print out 'Hello, ' without a newline.]
  [p Finally [code print] will print their name after the output from [code printw].]
  ]
]

[bite Infix Operators
  [p You may find writing out formulas in postfix to be tedious and difficult. Although this notation is somewhat fundamental to Fruity, it is not always necessary to use it. Fruity provides syntactic sugar that behaves more like the operators you are used to:]
  [repl
  1 + 2
  10 - 1
  3 * 4
  6 / 3
  23 % 5
  5 ^ 3
  ]
  [p Each of these are equivalent to their conterpart functions.]
  [p Note that, unlike in normal mathematics, these do not obey order of operations. They will always execute left-to-right.]
  [repl
  1 + 2 * 3
  ]
  [p Due to order of operations, that would usually be [code 1 + (2 * 3) = 1 + 6 = 7], however Fruity evaluates it as [code (1 + 2) * 3 = 3 * 3 = 9]. We can force it to evaluate the multiplication first by using a group.]
  [repl
  1 + (2 * 3)
  ]
  [p Fruity also contains comparison operators, similar to what most other languages have. These return either [code true] or [code false], which are a type of value we covered briefly before called an oddball.]
  [repl
  1 = 0
  1 != 0
  1 < 2
  'a' > 'b'
  2 <= 2
  'fish' >= 'fishy'
  ]
  [p Note that unlike many other languages, only a single equals is used for equality comparisons. This is because Fruity does not have an assignment operator.]
  [p There's one final comparison operator which behaves a tad differently:]
  [repl
  1 <> 1
  10 <> 20
  'banana' <> 'apple'
  ]
  [p This will compare two values, and return either -1, 0, or 1 depending on which is greater.]
]

[challenge Simpli-infix-ation
  [p Rewrite the following postfix formula using infix operators:]
  [repl
  21 5 2 add div 6 mul
  ]
  [answer
  [p This one is pretty straightforward. Note that we need to put [code 5 + 2] into a group to make it execute first.]
  [repl
  21 / (5 + 2) * 6
  ]
  ]
]

[bite Booleans
  [p In the previous bite we saw that we can generate boolean values by using comparison operators. These values can be combined using two functions:]
  [repl
  false true false all
  true true true all
  false true false any
  false false false any
  ]
  [p The [code all] function returns the final value if every value on the stack is truthy, and the first non-true value otherwise. The [code any] function returns the first truthy value if at least one value is truthy.]
  [p Note that the above description never mentions the values [code true] and [code false] directly. That's because these functions can operate on any kind of value. In Fruity, all values except for [code false] and [code nil] are considered as truthy.]
  [repl
  1 2 nil 3 all
  false nil 'hello' 32 any
  false 0 1 any
  ]
  [p Note that especially, unlike many other languages, 0 is considered a truthy value.]
  [p There is also a function to negate any value.]
  [repl
  true not
  false not
  32 not
  nil not
  ]
  [p In addition to these functions, there are infix special functions [code and ...] and [code or ...] that can be used for combining specifically two values. These behave just like the infix operators. In fact, all special functions (highlighted in purple here) in Fruity are infix. These are completely distinct from regular functions and are built into the language.]
  [repl
  true and false
  false or true
  nil or 32
  1 < 2 and (3 > 2)
  ]
]

[challenge Can I Ride?
  [p A ride in a theme park requires riders to be taller than 2.5m but below 3.9m. Write a program that determines whether or not you are allowed to ride.]
  [repl _USER_: {dup > 2.5 swap < 3.9 all}
  1.2 _USER_
  4.3 _USER_
  3.2 _USER_
  ]
  [answer
  [repl
  1.2 dup > 2.5 swap < 3.9 all
  4.3 dup > 2.5 swap < 3.9 all
  3.2 dup > 2.5 swap < 3.9 all
  ]
  [p First we use dup to get two copies of the number we want to work with. Then we use [code > 2.5] to determine if the value given is over 2.5.]
  [p Then we use swap to move that true/false value to the bottom, and the original number to the top. We then use [code < 3.9] to determine if the value given is under 3.9.]
  [p We now have two true/false values on the stack. We can then use the [code all] function to determine if both values are true, meaning both conditions were met.]
  ]
]

[bite Conditionals
  [p Usually when working with booleans, we will want to convert them into other values. We can do this with the [code then ... else ...] special function.]
  [repl
  1 = 1 then 'yes' else 'no'
  ]
  [p We can only have one value after each of [code then ...] and [code else ...]. If we wish to push multiple values, we must surround them in curly braces. This forms what is called a closure.]
  [repl
  false then {1 2 3} else {2 4}
  ]
  [p When code is surrounded in a closure like this, it is only executed if it needs to be, for instance a closure after a then is only executed if the value was truthy. We can use this to optionally execute code with effects:]
  [repl
  true then {'yes' print} else {'no' print}
  ]
  [p Both the then part and the else part are optional, so if you only want to do something in one of the two cases:]
  [repl
  true then 'ok'
  false then 'ok'
  1 else 'not ok'
  nil else 'not ok'
  true then {24 print}
  false then {24 print}
  ]
]

[challenge Can I Ride Now?
  [p A ride in a theme park has a minimum height of 2.4m. Write a program that, given a person's height, tells them whether they can ride using [code print].]
  [repl _USER_: {>= 2.4 then 'You may ride.' else 'Sorry, you must be at least 2.4m to ride.' print}
  3.6 _USER_
  1.2 _USER_
  ]
  [answer
  [repl
  3.6 >= 2.4 then 'You may ride.' else 'Sorry, you must be at least 2.4m to ride.' print
  ]
  [p We first use [code >= 2.4] to test if the value given is more than or equal to 2.4. Then we use a [code then ... else ...] statement to choose a string based off of the condition. Finally we use [code print] to display the chosen string.]
  ]
]

[bite Looping I
  [p Fruity contains several special functions for looping, most of which are a bit unorthodox. Starting with the more normal ones, we have repeat:]
  [repl
  3 repeat {'hello' print}
  10 3 repeat {* 2}
  ]
  [p Similarly to [code then ... else ...], the [code repeat ...] special function takes a closure and executes it several times. The amount of times is determined by a value popped off the stack before execution. Like other special functions, if a regular value is provided instead of a closure, it will be pushed multiple times.]
  [repl
  5 repeat 3.2
  15 repeat 'a' cat
  ]
  [p Another kind of loop is the [code until ... do ...] loop, which behaves like a while loop from other languages. The closure provided to [code until ...] will be executed first, and if it pushes a truthy value the closure provided to [code do ...] will be executed. This process repeats until the [code until ...] closure pushes a value that is no longer truthy.]
  [repl
  1 until {dup > 10} do {* 2}
  1 until {dup > 10} do {dup * 2}
  ]
  [p Note that we have dup in the first closure for both. If we did not, the value on top of the stack would be used up by the comparison, and the [code * 2] would produce a stack underflow (not enough values for the operator).]
  [p This can be used in combination with the [code size] function to interesting effect.]
  [repl
  1 until {size = 10} do {dup + 1}
  1 2 3 4 5 6 until {size = 1} do {add}
  'fish' 'cat' 'dog' until {size = 0} do {print}
  ]
  [p There is also a function, [code empty], which is equivalent to [code size = 0].]
  [repl
  'fish' 'cat' 'dog' until {empty} do {print}
  ]
  [p It is also worth mentioning that, like [code then ... else ...], both the [code until ...] and [code do ...] parts can be omitted. Omitting the [code until ...] part is not particularly useful as that just makes an infinite loop. The only way to break out of it is via an exception (covered later) or the [code exit] function, which terminates the program.]
  [repl
  1 until {+ 1 dup = 5}
  ]
]

[challenge Factorials
  [p A common function to demonstrate looping in various languages is the factorial. For any given positive number N, the factorial of it is the product of the numbers 1 to N. For example, the factorial of 5 is 1 * 2 * 3 * 4 * 5. Write Fruity code to calculate the factorial of a given number, using only the looping constructs covered so far.]
  [repl _USER_: {until {dup = 1} do {dup - 1} until {size = 1} do {mul}}
  6 _USER_
  ]
  [answer
  [p We can solve this with two loops, one to produce all the numbers from 1 to N, and another to multiply them together.]
  [repl
  6 until {dup = 1} do {dup - 1} until {size = 1} do {mul}
  ]
  [p The first loop will duplicate and subtract one from the value until it is one, giving us [code 6 5 4 3 2 1] in the above example. Then, the second loop will continuously multiply the top two values together, until there is only one value remaining.]
  [p It is also possible to solve with only one loop, can you figure it out?]
  ]
]

[bite Looping II
  [p A common situation is wanting to push a range of numbers to the stack. There is a special function for this also, [code to ...].]
  [repl
  1 to 5
  10 to 1
  ]
  [p If you want increments other than one, use the (regular) function [code math.range]]
  [repl
  1 5 0.5 math.range
  ]
  [p Another common situation is wanting to execute a piece of code for every value on the stack. The [code map ...] special function is meant for this very purpose.]
  [repl
  1 to 5 map {+ 1}
  'hello' 'darkness' map {print}
  ]
  [p This executes from the bottom of the stack upwards, so [mono hello] is printed first. If we use [code dump] to inspect what's happening, we can see how it works internally:]
  [repl
  1 to 5 map {dump}
  ]
  [p The [code map ...] special function first takes all values off the stack. It then pushes them back onto the stack one at a time, bottom to top, calling the provided closure each time.]
  [p Another closely related special function is [code filter ...].]
  [repl
  1 to 10 filter {% 2 = 1}
  ]
  [p This special function uses its closure as a predicate to determine whether or not to keep the given value in the final output. It's behavour can be mimiced by combining [code map ...] and [code then ... else ...], can you figure out how?]
]

[challenge 7 Times Tables
  [p Write a program that will produce the seven times tables, all the way up to 7 * 12. Try and do it without the [code math.range] function.]
  [repl _USER_: {1 to 12 map {* 7}}
  _USER_
  ]
  [answer
  [repl
  1 to 12 map {* 7}
  ]
  [p First we get the numbers from 1 to 12, and then multiply each by 7.]
  [p It can also be done with [code math.range].]
  [repl
  7 84 7 math.range
  ]
  ]
]

[bite Looping III
  [p Another common situation is wanting to repeatedly execute a piece of code until there is only one value left on the stack. We saw this earlier when covering [code until ...]. There is a special function just for this, [code fold ...].]
  [repl
  1 to 6 fold {mul}
  'a' 'b' 'c' fold {(. ', ' . cat)}
  ]
  [p Since repeatedly adding and multiplying are common operations, there are functions just for those:]
  [repl
  1 to 6 math.sum
  1 to 6 math.product
  ]
  [p As a side note, you can prefix most regular functions in the REPL by '$' to see the source code. The logic behind this will be explained later, but it might be interesting for now to look at some functions we've learned so far to see how they work.]
  [repl
  $math.sum
  $math.product
  ]
  [p Note that [code fold $add] is equivalent to [code fold {add}], but again that will be covered later.]
  [p The final major looping construct is [code zip ...]. This is very similar to [code map ...], but internally it works somewhat differently.]
  [repl
  1 to 5 zip {+ 1}
  #a #b #c zip {dup print}
  1 to 5 zip {dump}
  ]
  [p Like [code map ...] it can be used to apply a closure to each value on the stack. However, we can see from the second example that it starts from the top and works downwards. While [code map ...] will push then execute, [code zip ...] will execute then pop. Once it is done, all the popped values are returned to the stack. If the closure only takes in one value and produces one value, these two are mostly interchangable (except the order is reversed). Since [code map ...] pushes one value at a time, it can also be used when you want to take in one value and produce multiple. On the other hand, [code zip ...] can be used when you want to take in multiple but only produce one value.]
  [repl
  1 2 3 map {dup}
  1 2 3 4 zip {add}
  ]
  [p Most of the time, [code map ...] is the correct choice, but when you need to combine values on the stack (often in pairs), [code zip ...] is needed.]
]

[challenge Sum of Products
  [p Given a sequence of numbers, evaluate it as if every pair of numbers was a product, and each of the pairs was being summed together. For instance, the numbers [code 1 2 3 4 5 6] would be evaluated as if it were [code (1 * 2) + (3 * 4) + (5 * 6)]]
  [repl _USER_: {zip {mul} fold {add}}
  1 to 6 _USER_
  10 2 5 3 _USER_
  ]
  [answer
  [repl
  1 to 6 zip {mul} fold {add}
  1 to 6 zip {mul} math.sum
  ]
  [p First, [code zip {mul}] will multiply each pair of numbers. For [code 1 to 6], this will give us [code 2 12 30]. Finally we can use either [code fold {add}] or [code math.sum] to add all of these together.]
  ]
]

[bite Prefix Calls
  [p Commonly, you will find yourself creating a group just to call a function at the end, for example:]
  [repl
  2 * (5 2 3 math.sum)
  ]
  [p As this is such a common pattern, a convenience syntax is available that mimics other languages:]
  [repl
  2 * math.sum(5 2 3)
  print(add(1 mul(2 3)))
  32 'a' 1 cat(..)
  ]
  [p This is called a prefix call, or precall for short. Keep in mind that Fruity is whitespace sensitive, so [code print(1)] is distinct from [code print (1)], the latter executes [code print] first, then [code (1)].]
  [p There is also a syntax for when you want the prefix order but not a group, by appending a '!'.]
  [repl
  not! true
  print! 'hello world'
  1 add! 2
  1 2 cat! 3 4
  'a,b,c' .split! ','
  ]
  [p Note that [code .split] is not a regular function, but a 'method'. These functions, which start with a '.', are defined by the value on top of the stack, rather than being globally defined like the other functions we've seen so far. They pop this value when they are determined, which for precalls occurs before evaluation of the right hand side. This means all the below are equivalent:]
  [repl
  ',' 'a,b,c' .split
  'a,b,c' .split! ','
  'a,b,c' .split(',')
  ',' 'a,b,c' .split(.)
  ',' 'a,b,c' .split! ()
  ]
  [hint An aside: Fruity doesn't really have a concept of methods, more accurately this would be called a 'stack relative' or 'stack resolved' function, as the function is resolved relative to the value on top of the stack.]
  [p While we're on this topic, it's worth mentioning the [code join ...] special function, which is the inverse of [code .split].]
  [repl
  'a' 'b' 'c' join ','
  ]
  [p This resolves to calling the [code ._join] method on the [code ','] value. We could have instead written:]
  [repl
  'a' 'b' 'c' ',' ._join
  ]
  [p There's also the [code dot ...] special function, which dots by a given amount. So, [code dot 4] is equivalent to [code ....]]
  [repl
  1 2 3 4 5 reverse(dot 3)
  1 2 3 4 5 size - 1 (dot . .)
  ]
  [p The [code dot .] in the second example will dot by the amount [code size - 1], as that will be the value on top of the stack that the [code .] pulls through. This will move all but one value from the old stack, so then we have a final [code .] on the end to move the final value on top of the new stack. This is equivalent to the [code under] function - in fact, it might just be how that function is implemented.]
]

[challenge sdrawkcab sdrow
  [p This challenge is more so a test of all your knowledge so far, rather than just the above bite. Write code that, given a string, will reverse the letters of each individual word within in, while maintaining the overall order of the words. There are no restrictions. (Well, ideally do it in Fruity or that misses the point)]
  [repl _USER_: {.split! ' ' map {cat(. open reverse)} join ' '}
  'hello world' _USER_
  'fruity is stupid who made this crap' _USER_
  ]
  [answer
  [p There are many possible answers, here is mine.]
  [repl
  'hello world' .split! ' ' map {cat(. open reverse)} join ' '
  ]
  [p First we split the string into individual words with [code .split! ' '], and then we use [code map ...] to execute a closure for each of them. Within this closure, we reverse the string using a method similar to the earlier Sdrawkcab challenge. Because [code cat] operates on all values on the stack, we need to do this within a new group (otherwise values produced by previous executions of map's closure will be included). Finally, we use [code join ' '] to combine each word back together.]
  [p Although we've only covered around half the language so far, you can see it's more than enough to start implementing some reasonably complex operations. Think about how you might do this in your favourite programming language.]
  ]
]

[bite Modules I
  [p So far we've only covered using the REPL, however writing larger programs this way is rather impractical. Like any other language, you can write your source code into a file and run it in the interpreter.]
  [p Fruity source code conventionally uses the extension [mono .fj]. Write the following into a file, save it as [mono hello.fj], and then run it from a shell as shown:]
  [mono_bhl print('Hello, world!')]
  [mono_block $ fp hello.fj
Hello, world!]
  [p You can use [mono fp -h] to see available options, but usually you shouldn't need them.]
  [p Fruity code is organised into modules, each of which is generally represented by a single file. Fruity provides several modules providing various utilities. You can import a module into a file using [code import module_name], for instance [code import files] to import the [code files] module. The module will get loaded the first time it is imported, subsequent imports will refer to a cached copy.]
  [mono_bhl import math _NL_ print(1 2 3 math.sum)]
  [p Note that in the REPL, the [code math] and [code ds] modules are imported by default. We have seen some functions from the [code math] module already (those prefixed by [mono math.]). When writing code in [mono .fj] files, you need to import these explicitly before using any functions from them.]
  [p All of the functions you've seen so far (other than the math ones) are from the [code dragon] module, which is the standard library for Fruity. It's functions are available globally, but you can also access them by explicitly importing the dragon module.]
  [repl
  import dragon
  1 2 dragon.swap
  ]
  [p You can generally get a list of the contents of a module by using the [code lsv] function.]
  [repl
  $math lsv
  $dragon lsv
  ]
  [p This also works for finding methods on a value.]
  [repl
  'abc' lsv
  ]
  [p In fact, you can just do [code $math] like we did for viewing the source of a function, but for most modules it's quite verbose.]
  [repl
  $math
  ]
]

[challenge Fruitilicious Todo I
  [p For this challenge your goal is to make a todo list app. It only needs three features: adding to the list, seeing what's on the list, and removing from the list. Since this is quite a bit more complex than previous challenges, it is expected that you do this in a [mono .fj] file (although nobody's stopping you from doing a one-liner in the REPL if you want...)]
  [p An example interaction might be as follows:]
  [mono_block $ fp todo1.fj
Welcome to my Fruitilicious Todo App!!!
The commands are: 'add', 'list', 'remove' or 'exit'
Command: add
Task: water fish
Command: add
Task: drink plant
Command: list
- water fish
- drink plant
Command: remove
Task: drink plant
Command: list
- water fish
Command: exit]
  [p You don't have to copy this exactly, but it demonstrates the basic idea. Feel free to add in additional features if you want.]
  [p Warning: Implementing the remove command is a quite brutal without the content of the next bite, but a fun challenge. No shame in skipping that part if you find it too hard.]
  [hint Use the stack to store your todos. 'add' should be rather straightforward.]
  [answer
<pre><code><span class="keyword">print!</span> <span class="string">'Welcome to my Fruitilicious Todo App!!!'</span>
<span class="keyword">print!</span> <span class="string">'The commands are: \'add\', \'list\', \'remove\' or \'exit\''</span>
<span class="keyword">do</span> {
    <span class="keyword">prompt!</span> <span class="string">'Command: '</span>
    <span class="fn">dup</span> <span class="keyword">=</span> <span class="string">'exit'</span> <span class="keyword">or</span> {<span class="fn">dup</span> <span class="keyword">=</span> <span class="num">nil</span>} <span class="keyword">then</span> {<span class="fn">exit</span>}
    <span class="fn">dup</span> <span class="keyword">=</span> <span class="string">'add'</span> <span class="keyword">then</span> {
        <span class="fn">pop</span>
        <span class="string">'Task: '</span> <span class="fn">prompt</span>
        <span class="sym">#ok</span>
    }
    <span class="fn">dup</span> <span class="keyword">=</span> <span class="string">'list'</span> <span class="keyword">then</span> {
        <span class="fn">pop</span>
        <span class="keyword">map</span> {<span class="string">'- '</span> <span class="fn">printw</span> <span class="fn">dup</span> <span class="fn">print</span>}
        <span class="sym">#ok</span>
    }
    <span class="fn">dup</span> <span class="keyword">=</span> <span class="string">'remove'</span> <span class="keyword">then</span> {
        <span class="fn">pop</span>
        <span class="string">'Task: '</span> <span class="fn">prompt</span>
        <span class="keyword">zip</span> {
            <span class="fn">size</span> <span class="keyword">></span> <span class="num">1</span> <span class="keyword">then</span> {
                <span class="fn">swap</span> <span class="fn">dup</span> (<span class="keyword">..</span> <span class="keyword">.</span>)
                <span class="fn">dup</span> (<span class="keyword">.</span> <span class="keyword">..</span>)
                <span class="keyword">=</span> (<span class="keyword">.</span>)
                <span class="keyword">then</span> {<span class="fn">swap</span> <span class="fn">pop</span> <span class="sym">#dummy</span>}
                <span class="keyword">else</span> {<span class="fn">swap</span>}
            }
        }
        <span class="fn">under</span> <span class="fn">pop</span>
        <span class="keyword">filter</span> {<span class="keyword">!=</span> <span class="sym">#dummy</span>}
        <span class="sym">#ok</span>
    }
    <span class="keyword">!=</span> <span class="sym">#ok</span> <span class="keyword">then</span> {<span class="keyword">print!</span> <span class="string">'Command not recognised'</span>}
}</code></pre>
  [p The entire code is wrapped in a [code do ...] to loop forever. We use [code prompt] to get a message from the user, and then a series of [code dup = 'xxx'] to check which it is equal to. Each of these pushes [code #ok] at the end, so after all this if the value on the top of the stack isn't [code #ok] then we know the user entered an invalid command. This series of comparisons could be done more simply using either the [code chain] or [code switch] functions, but those haven't been covered.]
  [p The todo list itself is stored on the stack, and each of the three main commands just modifies the stack appropriately.]
  [p For adding to the list, we simply ask the user for their task. Since [code prompt] leaves it's result on the stack, it's all we need to do.]
  [p For printing out the list, we can use [code map ...] to execute the [code print] function for each value. We need to make sure to [code dup] before printing, otherwise the [code print] function would just pop it off the stack and we'd be left with an empty stack afterwards.]
  [p Remove is more complicated then the other two. For this one I used [code zip ...] to iterate over the entire stack, replacing any that didn't match the users input with [code #dummy], and then filtering out all the dummies at the end. The code inside the zip is a bit convoluted as it has to try and keep the users input on top for comparison. This would be much easier if we could just store the input somewhere else...]
  ]
]

[bite Variables
  [p Trying to write larger programs in Fruity, it quickly becomes apparent that just the stack is insufficient for storing all the values you need. Many other languages have variables, which allow you to assign a name to a value and then retrieve it again later by name.]
  [p Fruity is no different. You can pop a value off the stack and bind it to a variable with [code >>var], and get the value and push it to the stack with [code $var]. Accessing a variable that has not been bound is an error.]
  [repl
  'Jason' >>name
  $name
  $age
  ]
  [p Variables have a wide variety of usages. For instance, you could filter values from the stack based on user input as follows:]
  [repl
  'apple' 'banan' 'coconut' input >>x filter {!= $x}
  coconut
  ]
  [hint Isn't that much nicer than what we had for the previous challenge.]
  [p You can bind to a variable again to change it's value.]
  [repl
  1 >>x 2 >>x
  $x
  ]
  [p Like in many other languages, variables are scoped in Fruity. In Fruity, scopes are reified as 'contexts', which will be explained in a lot more depth later. For now, when you see 'context' think scope. Each closure (that is, the code within curly braces) defines it's own context. Variables from outside the context can be accessed, but binding will create a new variable in the current context instead.]
  [repl
  1 >>x true then {2 >>x}
  $x
  ]
  [p In the above, [code $x] still had the value 1, as 2 was only bound within the context of the closure passed to [code then ...]. If you do want to modify a variable bound in an outer closure, you can use the set syntax.]
  [repl
  1 >>x true then {2 >x}
  $x
  3 >y
  ]
  [p The set syntax can also be used to modify variables bound in the current context (and customarily is, to make it distinct from binding). It is an error to set a variable that has not already been bound.]
  [p Finally, there is also a syntax to check if a variable has been bound, by preceeding it with '?'.]
  [repl
  ?mychild
  'thou shalt be defined' >>mychild
  ?mychild
  ]
  [p Finally it is worth noting that, similar to the precall syntax, there is also a prebind syntax for variables.]
  [repl
  x: 2
  $x
  y: (2 * 3)
  $y
  ]
  [p Since it only takes the next syntactic unit as it's value, you need to create a group for anything longer.]
]

[challenge Personal Info I
  [p Write a program that, given a name, age, and occupation, prints it out in the following format.]
  [repl _USER_: {>>occu >>age >>name $name ' (' $age '). Occupation: ' $occu cat print}
  'Greg' 64 'Plumber' _USER_
  'Juan' '???' 'Unknown' _USER_
  ]
  [p Although this can be done entirely using stack operations and such, it is much easier to read using named variables.]
  [answer
  [repl
  'Greg' 64 'Plumber' >>occu >>age >>name $name ' (' $age '). Occupation: ' $occu cat print
  ]
  [p First we bind each part to a variable, then we push them to the stack one at a time in between the other parts of the message. Note that the variables are bound in reverse order to the values, that's because each will take the top value (so [code >>occu] will store [code 'Plumber'], as it's the top, and then [code >>age] will store [code 64] as it's the new top, etc.).]
  [p If you use nested prebinds instead, you don't need to reverse the order, as the rightmost prebind is evaluated first.]
  [repl
  'Greg' 64 'Plumber' (name: age: occu: ...) $name ' (' $age '). Occupation: ' $occu cat print
  ]
  ]
]

[bite Functions II
  [p Closures are considered a value in Fruity, no different to numbers or strings. We can push them to the stack and manipulate them however we want. This is also how the arguments to the special functions work.]
  [repl
  {swap add}
  {+ 1} {/ 2} swap
  ]
  [p There's even an [code apply] function which will execute a given closure.]
  [repl
  32 {+ 1} apply
  ]
  [p You may have realised by now, but regular functions are just closures bound as variables (special functions are the exception, those are implemented directly in the interpreter). The 'function syntax' that was introduced earlier is just a prebind and a closure. Earlier in an aside we saw how we could see a functions implementation with '$' - it should be clear now why this shows up as a closure (note the curly braces).]
  [repl
  $math.sum
  1 2 $add apply
  ]
  [p This also explains why the implementation for [code math.sum] uses [code fold $add] instead of [code fold {add}] - [code add] is already a variable containing a closure, so we can just pass that closure directly to [code fold ...] instead of creating a new one. Below is another example of passing the closure from a variable directly to a special function.]
  [repl
    1 2 3 map {+ 1}
    incr: {+ 1} 1 2 3 map $incr
  ]
  [p Using a variables name without any prefix/suffix will 'call' that variable, which is how we've been using functions all along. In the case of a closure this will execute it, for other values it will just push it.]
  [repl
  f: {'hello there!' print} x: 32
  f
  x
  ]
  [p There is also a third syntax for binding variables at the beginning of a closure, called signature binding (sigbinding). This is commonly used when defining functions to give them a clear signature, but it can be used with any closure (they're all the same, after all). It looks as follows:]
  [repl
  1 2 3 fold {x y => $x + $y}
  show_person: {name age => print($name ' (' $age ')' cat)}
  show_person('james' 32)
  ]
  [p Sigbinds bind in reverse order, much like nested prebinds do, so the rightmost sigbind is bound first (i.e. is the value on top of the stack).]
]

[challenge Reverse N
  [p Write a function [code revn] that, given a number N on top of the stack, reverses the top N values only.]
  [repl revn: {n => reverse(dot $n)}
  'abcde' open 3 revn
  ]
  [hint Remember the [code dot ...] special function?]
  [answer
  [repl
  revn: {n => reverse(dot $n)}
  'abcde' open 3 revn
  ]
  [p First we bind the value on top of the stack to the variable n, then we create a group with which we pull the top n values into using [code dot $n]. Finally the [code reverse] function will reverse these values before the group ends, pushing them back onto the original stack.]
  [p This can actually be done without binding the variable n:]
  [repl
  revn: {reverse(dot .)}
  'abcde' open 3 revn
  ]
  ]
]

[bite Contexts
  [p Earlier I mentioned that all variables are bound within a context. These contexts can also be manipulated as values in Fruity. To access the context of the currently running code, use the [code this] keyword.]
  [clrrepl2]
  [repl
  32 >>x this
  ]
  [clrrepl]
  [p The 'inherited' part there refers to all the variables bound outside the context that are still accessible from it.]
  [p Beware, if you bind a context to a variable within itself and then try and print that context on the repl, it will crash from infinite recursion.]
  [p Manipulating contexts like this allows us to imitate objects from other languages like JavaScript, and so there is a short hand syntax for creating them.]
  [repl
  :{x: 32 y: 'yes'}
  ]
  [p This will often be called an 'object', but it's only syntactic sugar. It is equivalent to:]
  [repl
  {x: 32 y: 'yes' this} apply as nil
  ]
  [p Inside the braces is just a regular closure that gets executed immediately, and one it's done it pushes its context. It also wipes the inherited variables - this is what [code as nil] does.]
  [p There are also a series of functions to manipulate contexts programatically. These correspond to each of the variable operations we've seen so far:]
  [repl
  j: :{'james' >>name 32 >>age}
  $j #name getv
  $j #age 33 setv
  $j #gender #m bindv
  $j
  $j #occupation hasv
  ]
  [p Variable names are always represented as symbols, not strings.]
  [p Additionally, there is [code lsv] that we saw before briefly, which lists each of the variables bound within a context.]
  [repl
  $j lsv
  ]
  [p There is also [code hasb] and [code lsb], which behave like their [mono -v] counterpart, but ignore inherited variables (b is for 'bound').]
  [p All of the globally available functions are bound in a special context called [code root]. Because [code root] is bound within itself, it can't be printed directly in the REPL.]
  [repl
  $root
  $root lsv
  ]
  [p This is the same as the module you get from [code import dragon]. We can show this using the [code is ...] special function, which returns whether two values refer to the same thing (this is distinct from regular equality, which is undefined for contexts).]
  [repl
  import dragon
  root is dragon
  ]
]

[challenge Context Content
  [p Write a function that, given a context, prints each variable bound in the following manner:]
  [repl pctx: {c => ($c lsv map {s => cat($s ' -> ' $c $s getv rep) print})}
  :{x: 32 y: 'fish'} pctx
  ]
  [p Use [code rep] to display the value.]
  [answer
  [p We can use [code lsv] to list the keys, [code map ...] to iterate over them, and [code getv] to retrieve the value.]
  [repl
  pctx: {c => ($c lsv map {s => cat($s ' -> ' $c $s getv rep) print})}
  :{x: 32 y: 'fish'} pctx
  ]
  [p We create an additional group within the closure so that the [code map ...] doesn't include anything else that may have been on the stack before the function was called.]
  ]
]

[bite Chaining
  [p Often you will want to access a variable defined in a different context. Although this can be done with [code getv] and friends, it's not very convenient when we're looking up a fixed name. All of the variable related syntax we've seen so far looks up values within the current context, but if we prefix the variable name with a dot it will instead pop the top value off the stack and resolve it relative to that.]
  [repl
  j: :{'james' >>name 32 >>age}
  $j $.name
  33 $j >.age
  #m $j >>.gender
  $j
  $j ?.occupation
  ]
  [p This is what the 'methods' that were briefly mentioned before actually are. There is a context shared by all strings which contains several useful functions, such as [code split]. When we call a 'method' by prefixing it with dot, we are just resolving a function relative to the string's context.]
  [repl
    'a,b,c' .split(',')
  ]
  [hint The particularly astute might notice that implementing such a function is impossible given what's been covered so far.]
  [p If we had a series of nested objects, typing a series of variable accesses would quickly become cumbersome, and if you haven't noticed yet half of Fruity's syntax is just syntactic sugar to make the other half look more like JavaScript, so of course there's a short hand for this.]
  [repl
  a: :{b: :{c: 32}}
  $a.b.c
  $a $.b.c
  16 >a.b.c
  $a.b
  ]
  [p This is called a chain. Even in simpler cases like [code $foo] the part after the prefix is still called a chain. Each element of the chain is separated by a dot. The variable being accessed/bound/etc. is the final one. Chains can be arbitrarily long, each variable is resolved relative to the previous one.]
  [p The earlier example could be rewritten to:]
  [repl
  j: :{'james' >>name 32 >>age}
  $j.name
  33 >j.age
  #m >>j.gender
  $j
  ?j.occupation
  ]
  [p Modules are also contexts. When we import a module, we are really binding a context in the current scope. [code import math] is roughly equivalent to [code :{...} >>math], where the dots are replaced with the contents of the math module. When we access a function within a module such as [code math.sum], we are using the exact chaining syntax described above. If we wanted to, we could access [code math.sum] as follows:]
  [repl
  1 2 3 $math .sum
  ]
]

[challenge Personal Info II
  [p Write a function that, given a context containing name, age, and occupation, prints it out in the following format. The age or occupation may be missing, in which case you should omit those parts.]
  [repl showp: {p => print($p.name ?p.age then {$p.age} ?p.occu then {$p.occu} join ' ')}
  :{name: 'Greg' age: 64 occu: 'Plumber'} showp
  :{name: 'Juan'} showp
  ]
  [answer
  [repl
  showp: {p => print($p.name ?p.age then {$p.age} ?p.occu then {$p.occu} join ' ')}
  :{name: 'Greg' age: 64 occu: 'Plumber'} showp
  :{name: 'Juan'} showp
  ]
  [p We can access each of the variables using [code $p.name], [code $p.age], and [code $p.occu]. For the latter two we first check their existence with the '?' prefix.]
  ]
]

[bite Parenting
  [p In Fruity, contexts may have another context specified as their 'parent'. If a variable can't be found, then it will try and resolve it in the parent context. This is how, for example, the variable [code x] is resolved in the following code:]
  [repl
  x: 32 true then {$x print}
  ]
  [p Although the code is within another closure, that closure's context has the outer code's context as it's parent, so it is able to resolve the variable. A closure's context's parent is determined by the current context when the closure is pushed initially - i.e. the context of the closure in which it is defined. This allows it to 'capture' variables from the outer closures scope, enabling a more functional programming style:]
  [repl
  make_add: {x => {+ $x}}
  add2: make_add(2)
  add40: make_add(40)
  $add2 $add40
  add2(7)
  add40(7)
  ]
  [p Here, the [code add2] function's parent is a context where [code x: 2], meanwhile the [code add40] function's parent is a context where [code x: 40], so although they both contain the exact same code they produce different results.]
  [p It's worth noting that the root context containing functions like [code swap] and [code dup] is usually the 'highest' parent of every closure, which is how they can access these functions. If the series of parents gets broken, these functions can no longer be accessed.]
  [p You may recall from earlier that objects 'wipe' their inherited variables. This is achieved by removing their parent (these inherited variables are just variables defined on their parent or their parent's parent etc.). This will however impact any functions declared within the object. The next bite will cover the trick for getting around this.]
  [repl
  jason: :{name: 'Jason' greet: {print('hey im ' $name '!' cat)}}
  $jason
  jason.greet
  ]
  [p In the above example, [code jason.greet] can only access [code name] and [code greet]. It does not inherit the functions from [code root], so [code print] is unavailable. We could (awkwardly) get around this with an explicit import.]
  [repl
  jason: :{name: 'Jason' greet: {import dragon dragon.print('hey im ' $name '!' dragon.cat)}}
  jason.greet
  ]
  [p The functions [code getp] and [code setp] are used to manually inspect and change a context's parent. We can use this to imitate the prototypal inheritance seen in languages like Lua or JavaScript. In the REPL's display, inherited variables appear in gray.]
  [repl
  child: :{x: 2}
  $child getp
  $child
  parent: :{x: 10 y: 20}
  $child $parent setp
  $child getp
  $child
  ]
  [p There is also the special function [code as ...] to change a context's parent.]
  [repl
  parent: :{y: 10}
  :{x: 20} as $parent
  ]
  [p Unlike [code setp], using [code as ...] leaves the child context on the stack, making it convenient when writing constructor-like functions:]
  [repl
  proto_person: :{name: 'Prototype' age: nil occu: nil}
  make_person: {:{>>name} as $proto_person}
  james: make_person('james')
  $james
  ]
]

[challenge Personal Info III
  [p Write a function that, given a string containing personal info, creates a context from it. Values that are not present should have default values inherited from a parent context. Assume the first value is always name, second age, and third occupation.]
  [repl P: :{name: 'Unknown' age: '???' occu: 'None'} fromp: {.split(' ') filter {len > 0} reverse p: :{} empty else {>>p.name} empty else {int >>p.age} empty else {>>p.occu} $p as $P}
  'Greg 64 Plumber' fromp
  'Julia 32' fromp
  'Juan' fromp
  '' fromp
  ]
  [answer
  [repl
  Person: :{name: 'Unknown' age: '???' occu: 'None'}
  fromp: {.split(' ') filter {len > 0} reverse p: :{} empty else {>>p.name} empty else {>>p.age} empty else {>>p.occu} $p as $Person}
  'Greg 64 Plumber' fromp
  ]
  [p First we split the string into words and filter out any empty parts with [code .split(' ') filter {len > 0}]. Then we [code reverse] the stack so the first part of the string is on top. Then for each of the variables we bind them if the stack is not yet empty, then finally we set the parent to a prototype object with default values we defined earlier.]
  [p By convention, I usually name prototype objects with a capital letter to distinguish them from the constructor.]
  [p Honestly most of the difficulty in this challenge has nothing to do with parenting, I should probably change it.]
  ]
]

[bite Self
  [p Earlier I mentioned that the [code .split] method on strings is impossible given what we know so far. So how is it implemented? Let's take a look.]
  [repl
  'im a string' $.split
  ]
  [p We can see that it sigbinds the delimeter to delim, pushes a variable called [code $self], pushes [code $delim], then calls [code builtin.strsplit], which is a C function that implements string splitting.]
  [p Of interest to us is that first variable, [code $self]. That variable is not bound in the closure or any of it's parent contexts - we can show that with the following ([code getp] on a closure returns the context that will be it's parent when it executes):]
  [repl
  'abc' $.split getp ?.self
  ]
  [p Instead it is bound when we call the function. Whenever a variable is called using a dot (i.e. relative to anything other than the current context, such as [code math.sum] or [code .split]), the value it is resolved relative to is bound as [code $self] within that function.]
  [p We can demonstrate this with our own contexts:]
  [repl
  obj: :{x: 32 show: {('my self is' $self join ' ')}}
  obj.show
  ]
  [p This is useful for writing methods on objects. We can put such methods on parent contexts as well, and the value passed as self will be the child.]
  [repl
  Animal: :{}
  Animal.show: {print($self.name 'goes' $self.sound dup join ' ')}
  dog: (:{name: 'dog' sound: 'bork'} as $Animal)
  catto: (:{name: 'cat' sound: 'meow'} as $Animal)
  fox: (:{name: 'fox' sound: '???'} as $Animal)
  dog.show catto.show fox.show
  ]
  [hint Originally I used [code cat] instead of [code catto] and then a later bite messed up when I used the [code cat] function. Be careful using global function names, yo!]
  [p Importantly, we define the method outside of the object for Animal. If we defined the function within it, it would have Animal set as it's parent. Since Animal will have it's parent set to [code nil], the function will not be able to resolve global variables. A similar issue would occur with [code obj.show] from before, that function only works because it doesn't rely on any globally defined variables.]
]

[challenge Personal Info IV
  [p Write a show method for the prototype person we defined earlier to print out a person's details]
  [repl Person: :{name: 'Unknown' age: '???' occu: 'None'} Person.show: {print($self.name $self.age $self.occu join ' ')}
  :{name: 'Greg' age: 64 occu: 'Plumber'} as $Person .show
  :{name: 'Juan'} as $Person .show
  ]
  [answer
  [repl
  Person: :{name: 'Unknown' age: '???' occu: 'None'}
  Person.show: {print($self.name $self.age $self.occu join ' ')}
  :{name: 'Greg' age: 64 occu: 'Plumber'} as $Person .show
  :{name: 'Juan'} as $Person .show
  ]
  [p For this one we just need to access name, age, and occu relative to [code $self] and then join them with spaces.]
  ]
]

[bite Lists
  [p Finally we can move on from contexts! Another really useful type in Fruity is the list. Using the [code list] function, every value on the stack will be 'compressed' into a single list value. This can be useful for storing and restoring the stack later, or for more complex operations requiring several stacks at once.]
  [repl
  1 2 3 list
  1 2 3 list 4 5 list
  ]
  [p The [code open] function, which we saw earlier on strings, has a similar functionality for lists, pushing each of their values back onto the stack.]
  [repl
  list(1 2) open
  list(1 2) list(3 4) swap open
  ]
  [p Another useful function is [code len] which will give you the size of a list. It works on strings too.]
  [repl
  list(1 to 10) len
  ]
  [p Lists have a lot of methods available to simplify working with them. Here are some of the most useful:]
  [repl
  l: list(1 'apple' #banan)
  l.find(#banan)
  l.contains(#coconut)
  100 l.push $l
  l.pop $l
  l.append(1 2 3) $l
  l.get(2)
  ]
]

[challenge Even Odds
  [p Write a function that given a stack of integers will reorder all the even numbers to be below all the odd numbers. It should otherwise preserve their orders.]
  [repl evenodd: {odds: list() map {dup % 2 = 1 then {odds.push}} $odds open}
  1 2 3 4 5 6 evenodd
  10 15 401 17 30 28 29 evenodd
  ]
  [answer
  [repl
  evenodd: {odds: list() map {dup % 2 = 1 then {odds.push}} $odds open}
  1 2 3 4 5 6 evenodd
  10 15 401 17 30 28 29 evenodd
  ]
  [p For this one we first create a list to contain each of the odd numbers, then we map over all numbers and put those that are odd into the list (removing them from the stack in the process), then finally we push all the odd numbers onto the stack at the end.]
  [p Note that we cannot use [code then $odds.push] here, as doing so would fail to bind the [code self] value for push, and so it would not be able to access the list.]
  ]
]

[bite Exceptions
  [p In Fruity, exceptions are thown whenever code tries to do something that is not possible. You should've seen some of these by now - if you made it this far without making a single mistake then congratulations... I guess?]
  [repl
  pop
  no_such_var
  ]
  [p Every exception has three parts. The key is a symbol that identifies what kind of exception this is. You can use this in your code to determine how to handle the exception. The message is a more detailed message intended only to be shown to humans. Finally, the trace is a list of lines of code that were being executed between where the exception was raised and where it was caught.]
  [p These exceptions can be caught by the [code catch ...] special function. This function will execute a closure from the stack. If the closure throws an exception, it will push a context containing information about that exception to the stack and then execute the closure on it's right.]
  [repl
  {pop} catch {'caught a big one' print}
  ]
  [p You can throw your own exceptions with the [code throw] function.]
  [repl
  #invalid throw
  ]
  [p In addition to using [code catch ...], there is also the [code safe] function that can be used to execute code 'safely'. It tries to execute a closure and then pushes a boolean value indicating whether it executed successfully.]
  [repl
  {pop} safe
  {1 + 2} safe
  ]
  [p Fruity defines 5 symbols for exceptions, these are: [code #unbound] for accessing an unbound variable, [code #underflow] when the stack doesn't have enough values for the operation, [code #type] when a value isn't of the expected type, [code #invalid] when a value is not in the range of acceptable input, and [code #internal] if something goes wrong internally. You are free to use these or other symbols in your own code.]
]

[challenge Try Execute
  [p Write a function that, given a closure, will try to execute it. If an exception is raised, it should push the symbol of the exception.]
  [fcase
  {pop} try
  #underflow
  ]
  [fcase
  {1 + 2} try
  3
  ]
  [answer
  [repl
  try: {catch {$.key}}
  {pop} try
  {1 + 2} try
  ]
  [p The [code catch ...] special function already provides most of the functionality we need. In the case where an exception is thrown, we just extract the [code #key] variable from the exception context.]
  ]
]

arguments (leave for later?)

[bite Metamethods
  [p In Fruity, the comparison operators are defined for all types except contexts. (Yes, even closures, which always return false)]
  [repl
  1 < 2
  'a' < 'b'
  {} < {}
  :{x: 1} < :{y: 2}
  ]
  [p For contexts, Fruity will attempt to resolve a variable called [code _cmp]. If it finds it, it will be invoked and it's result used to determine the ordering. It's output should mimic that of the [code <> ...] operator, where [code self] is the left hand side.]
  [repl
  a: :{x: 1}
  b: :{x: 2}
  a._cmp: {other => $self.x <> $other.x}
  $a < $b
  $a > $b
  $a <= $b
  $a >= $b
  $a <> $b
  ]
  [p Similarly, the [code =] and [code !=] operators will call the value bound to [code _eq] if it is found.]
  [repl
  a._eq: {other => $self.x = $other.x}
  $a = $b
  $a != $b
  ]
  [p I call these underscore-prefixed methods 'metamethods', but the language doesn't recognise them as anything special. The arithmetic operators can also be overloaded. Each of them looks up a symbol name equivalent to the corresponding function (so, [code _add] for [code + ...], [code _mod] for [code % ...]). This is used by [code math.complex] to implement complex numbers using contexts.]
  [repl
  a._add: {other => :{x: ($self.x + $other.x)}}
  $a + $b
  math.complex(1 2) + math.complex(3 4)
  math.complex(1 2) $._add
  ]
  [p Finally, some common functions use underscore-prefixed methods, for instance [code str], [code len] or [code open]. This is how they work across multiple types. Viewing their source reveals the symbol they use.]
  [repl
  $len
  a._len: {$self.x}
  $a len
  ]
  [p Usually these methods will be bound to a parent object that is shared amongst all values of a custom type. As an example, here is how we might implement a 2d vector type with support for [code str], [code + ...], and [code open].]
  [repl
  Vec2: :{}
  vec2: {:{x y =>} as $Vec2}
  Vec2._open: {$self.x $self.y}
  Vec2._add: {other => $self.x + $other.x $self.y + $other.y vec2}
  Vec2._str: {cat('vec2(' $self.x ' ' $self.y ')')}
  vec2(7 4) str
  vec2(1 2) + vec2(3 4)
  vec2(2 9) open
  ]
  [p If you want to overload the way values are displayed in the REPL, that uses the [code _visit] metamethod. If you have implemented [code open] as an inverse of your constructor, you can implement [code _visit] like this:]
  [repl
  Vec2._visit: {.openable('vec2' self)}
  vec2(6 5)
  ]
  [p [code _visit] is intended to be a generic visitor pattern for values. You can look at the [code crayons] module source to see the visitor used by the REPL.]
]

[challenge It's That Time Again
  [p Implement a function, [code hour], that given an hour from 0 to 23 creates a context. This context should support addition, subtraction, equality, and [code str]. The string produced should be in 12 hour time. Internal representation is up to you.]
  [repl Hour: :{} hour: {% 24 dup < 0 then {+ 24} :{v =>} as $Hour} Hour._add: {$self.v + $.v hour} Hour._sub: {$self.v - $.v hour} Hour._eq: {$self.v = $.v} Hour._str: {$self.v dup >= 12 then {- 12 true} else false swap dup = 0 then {+ 12} cat(. . then 'pm' else 'am')}
  23 hour str
  0 hour str
  hour(2) + hour(6) str
  hour(2) - hour(6) str
  hour(2) = hour(14)
  hour(0) = (hour(23) + hour(1))
  ]
  [answer
  [repl
  Hour: :{v: 0}
  hour: {% 24 dup < 0 then {+ 24} :{v =>} as $Hour}
  Hour._add: {$self.v + $.v hour}
  Hour._sub: {$self.v - $.v hour}
  Hour._eq: {$self.v = $.v}
  Hour._str: {$self.v dup >= 12 then {- 12 true} else false swap dup = 0 then {+ 12} cat(. . then 'pm' else 'am')}
  ]
  [p In our constructor function we use [code % 24 dup < 0 then {+ 24}] to map the input into the range 0-23, then we create an object with [code $Hour] as it's parent. We provide a default value of 0 for [code v] incase someone tries to use the prototype object directly.]
  [p Our [code _add], [code _sub], and [code _eq] implementations are pretty straighforward, as we just perform the operation on the [code $.v] value. We don't need to worry about wrapping around etc. as [code hour] handles that for us.]
  [p [code _str] is a bit more fun, first we check if it's in the afternoon, and if so we subtract twelve. We also push whether or not it was in the afternoon (this could also have been done by just duplicating the condition and some swapping). We use [code swap dup = 0 then {+ 12}] to change any zeroes to twelves, and finally form the string with [code cat].]
  ]
]

[bite Modules II
  [p Fruity provides a lot of modules with various functionality. In this bite we'll cover some of them and how they can be used. Most of the modules are currently incomplete, but the most basic functionality is there.]
  [p The [code math] module contains a lot of mathematical functions. These should all be relatively familiar, and we've seen several already. You can get a full listing with [code $math lsv]]
  [repl
  $math lsv
  math.sin(90)
  2 * $math.pi
  math.sqrt(25)
  10 repeat {math.rand_range(1 100)}
  math.median(4 2 1 6 5)
  math.complex(1 1) * math.complex(0 2)
  ]
  [p The [code ds] module provides various data structures and some useful utility functions. [code ds.pair] is a pair of two values, [code ds.grid] is a 2d array, and [code ds.dict] is an associative array.]
  [repl import ds
  $ds lsv
  ds.pair(2 'fish')
  g: ds.grid(2 2)
  g.fill(#a) g.set(0 0 #b)
  g.row(0)
  d: ds.dict(1 'one' 2 'two')
  d.get(1)
  d.keys
  'cat' 'dog' 'fish' 'cat' 'cat' 'dog' ds.tally print
  :{index: 2 s: 'Second'} :{index: 1 s: 'First'} :{index: 3 s: 'Third'} #index ds.sortkey
  ]
  [p The [code crayons] module provides various functions for formatting text on the terminal. The [code crayons.rep] function is what the REPL uses to display colored values.]
  [repl
  import crayons
  crayons.blue('im blue dabadee dabadie') print
  crayons.bold(crayons.red('oh no, error happen!')) print
  crayons.rep(:{x: 32 y: list('fish' #sticks)}) print
  ]
  [p The [code files] module provides functions for working with the file system.]
  [repl
  import files
  $files lsv
  files.write('hello.txt' 'Hello, World!')
  files.read('hello.txt') print
  files.join('..' 'src')
  files.ls('../src')
  ]
  [p The [code kiwi] module implements a basic markup language. This series of tutorials are actually generated entirely with Fruity, using this module for markup. This module was written back in 2015 and I'm not even fully sure how some of it works anymore.]
  [repl
  import kiwi
  my_ctx: ($kiwi.ctx_base + :{})
  my_ctx.bold: $crayons.bold
  my_ctx.reverse: {cat(. open reverse)}
  s: 'hello [lb]bold everyone[rb] my [lb]reverse name[rb] is [lb]bold mr [lb]reverse squirgle[rb][rb].'
  $s $my_ctx kiwi.parse_string print
  ]
  [p The [code regex] module provides basic regex matching functionality using PCRE2.]
  [repl
  import regex
  regex.match('l+' 'hello world')
  regex.match_all('l+' 'hello world')
  regex.match('\\.[lb]a-z[rb]{3}' 'my_file.txt')
  regex.match('([lb]a-zA-Z0-9[rb]+)\\.(com|net|org)' 'sekien.net')
  ]
  [p Finally, the [code repl] module implements the default REPL you've been using. You can bypass this and use the builtin REPL with the [mono -f] command line option, if you like. This module provides some utilities, notably the [code minirepl] function that allows you to quickly make your own REPL-style interface.]
  [repl
  import repl
  1 to 5 reverse
  repl.prev map {+ 1}
  {s => s.upper} repl.minirepl
  hello
  we come in peace
  ]
  [p The [code repl.prev] function pushes the contents of the stack from the previous line, or the exception if an exception was raised. This is useful for more iterative style programming, slowly trying each step one at a time. You don't need to import [code repl] for this, it is also bound as [code prev] by default.]
]

[challenge Car Spotters
  [p Write a program to record the colors of cars that go by, and then print out the frequency of each color in order. The first one should be bolded, and each color should be colored appropriately if [code crayons] has a function of that name.]
  [mono_block $ ./fp carfreq.fj 
Enter in the colors you saw.
use ctrl-d to exit minirepl
- red
- green
- blue
- orange
- green
- blue
- white
- red
- red
- <span class="comment">&lt;ctrl-d&gt;</span>
5 unique colors:
<span class="var bold">3 red cars</span>
<span class="sym">2 blue cars</span>
<span class="string">2 green cars</span>
1 white car
1 orange car]
  [answer
  [mono_bhl import repl.minirepl _NL_
import crayons _NL_
import ds _NL_
 _NL_
print('Enter in the colors you saw.') _NL_
 _NL_
plural: {s => = 1 then $s else {cat($s 's')}} _NL_
 _NL_
colors: list() _NL_
minirepl! {colors.push} _NL_
 _NL_
$colors open ds.tally .entries ds.sortkey! #tail _NL_
 _NL_
map { p => _NL_
_TAB_ cat($p.tail $p.head $p.tail 'car' plural join ' ') _NL_
_TAB_ hasv($crayons $p.head sym) then {getv($crayons $p.head sym) apply} _NL_
} _NL_
 _NL_
empty else $crayons.bold _NL_
 _NL_
size print(. dup ' unique color' plural ':' cat) _NL_
reverse map $print]
  [p First we import the modules we'll be using. Since we only need [code minirepl] from [code repl] we'll just import it directly.]
  [p We use [code minirepl] to get colors from the user and push each of them into a list.]
  [p We use [code ds.tally] to determine the frequency of each color, and then [code ds.sortkey] to put them into order.]
  [p We then map over each value making a string out of it. We check if [code crayons] has a value corresponding to the given name and call it. This leads to weird behaviour if the user enters [mono bg] or [mono rep] as a color but oh well.]
  [p We bold the first line (top of stack) with [code crayons.bold], then finally print them all out with a map.]
  ]
]

[bite Modules III
  [p Fruity looks for modules in various directories. By default, it will search the following directories:]
  [mono_block /usr/local/lib/fruity
~/.local/lib/fruity]
  [p You can add additional paths to search on with the [mono -M] option via the commandline.]
  [mono_block $ fp -M .
$ fp -M ../modules]
  [p When executing a statement like [code import mymod], first it will look for a file called [mono mymod.fj] in the first path. If it can't find it, it will look for a file called [mono modmymod.so]. It will then repeat this for the next path and so on until a file is found or all paths are exhausted.]
  [p If the file found is a [mono .so] file, it will be loaded as a native module. The internal API is not yet stable (aka it's a complete mess), but you can see some examples of how these can be written by looking at the [mono src/modules] directory of the distribution.]
  [p If the file found is a [mono .fj] file, it will execute the content of that module in a new context, and cache the resulting context as the module to then be bound by the import statement. If the context has the variable [code _export] bound, it will cache that instead. This can be used to implement basic encapsulation, by defining variables you want to export on a separate object and binding that to [code _export].]
  [mono_bhl
  _export: :{} _NL_
  rev_str: {s => cat($s open reverse)} _NL_
  _export.rev_words: {s => _NL_
  _TAB_ (s.split(' ') map $rev_str join ' ') _NL_
  } _NL_
  ]
  [p The above module would export the function [code rev_words], but [code rev_str] would not. The encapsulation isn't perfect, [code rev_str] could still be accessed by doing [code $.rev_words getp $.rev_str].]
  [p When a file is invoked directly from the commandline (or by the [mono -m] option), it will have the variable [code _main] bound. You can check the presence of this to optionally do something when a file is ran as main. The [code crayons] module uses this to display a test message - try it with [mono $ fp -m crayons].]
  [p Importing also allows you to alias the import using the syntax [code import module as alias], which simply binds under the given alias. You can also import a specific variable from within a module using [code import module.key], for instance we could do [code import math.sum] which would bind the value for the sum function to [code sum] in the current context.]
  [p You can also import a file that's not on the module path with the relative import statement. This will look for either a .fj or .so file in the same directory as the source file containing the statement. This can be used to split your own programs up into multiple files without needing to modify the module paths.]
  [mono_bhl
  import .utils _NL_
  import .utils.parse_email _NL_
  import .utils.parse_email as p_email
  ]
  [p This is the same as the regular import statement, but we prefix the module name by a dot.]
]
[challenge Fruitilicious Todo II
  [p Improve on your todo list from before. Use the features you've learnt like lists and variables to simplify your code. Feel free to make this as simple or as complex as you'd like. How much can you improve it over your first one? Maybe some fancy colors with [code crayons], or persistence with [code files]?]
]

[bite What Next?
  [p Congratulations, if you've followed the tutorials up to here then your probably the only other person in the world who knows this language! This is more of a toy language, so it's not particularly useful for writing large programs, but I've found various uses for it over the years just for simple scripts or answering random questions (like, whats the sum of the first 10 prime numbers?).]
  [p If you want to learn more, you can look through some of the example programs, as well as the source to the various modules.]
]
[challenge
  [p Make something cool, or contribute back to Fruity itself! There's still lots of work to be done and testing needed. Feedback is always welcome, too.]
]
