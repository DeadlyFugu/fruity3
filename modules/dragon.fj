import builtin as _builtin

// This first part just gets the 8 default parents made by the interpreter.

1 _builtin.getp >>Number
#a _builtin.getp >>Symbol
'a' _builtin.getp >>String
{} _builtin.getp >>Closure
nil _builtin.getp >>Oddball
_builtin.list _builtin.getp >>List
@a 1 _builtin.getp >>Argument
{.} catch {} _builtin.getp >>Exception
&x _builtin.getp >>Reference

pop: {x =>}
dup: {x => $x $x}
swap: {(. .)}
clear: {map $pop}
top: {x => clear $x}
size: $_builtin.stksize
empty: {size is 0}
under: {size - 1 (dot . .)}
reverse: $_builtin.reverse

dump: $_builtin.dump
sort: $_builtin.sort

add: {o => + $o}
sub: {o => - $o}
mul: {o => * $o}
div: {o => / $o}

// todo: should .tostr be the casting method instead?
str: {dup ?.str then {.str} else $_builtin.valstr}
rep: {dup ?.rep then {.rep} else $str}

print: {str '\n' _builtin.strcat(..) _builtin.dbgput}
printw: {str _builtin.dbgput}
input: $_builtin.dbgget

match: {f =>
    ?f.match then {dup f.match}
    else {dup is $f or! {$f is default}}
}

apply: {f => f}
cat: {map $str _builtin.strcat}
join: {s => map $s pop cat}
mkstr: $_builtin.strmk
char: {
    dup type
    is #Number then {mkstr(.)}
    else $_builtin.strunmk
}
sym: $_builtin.sym

getv: $_builtin.getv
setv: $_builtin.setv
bindv: $_builtin.bindv
hasv: $_builtin.hasv
refv: {:{self key =>} as $Reference}
lsv: $_builtin.lsv
getp: $_builtin.getp
setp: {b => as $b pop}
type: $_builtin.type

bool: {then true else false}
not: {then false else true}
and: {a b => $a then $b else $a}
or: {a b => $a then $a else $b}

int: {.int}
float: {.float}
// abs: {.abs}
negate: {0 - ()}

open: {.open}
len: {.len}

switch: {
    reverse >>val
    until {
        
        // eval condition
        // dup type is #Closure
        // then {.apply($val)}
        // else {k => $k is $val  or! {$k is default }}
        $val swap match swap pop
        // remove body if false
        dup else {swap pop}
        
        or! $empty
    }
    empty else {top apply}
}
chain: {
    reverse
    until {empty or! $apply} do $pop
    empty else {top apply}
}
filter: {f => map {n => f($n) then $n}}

profile: {
    start: _builtin.clock
    clear(. apply)
    end: _builtin.clock
    $end - $start
}

Number.float: {self}
Number.int: {self _builtin.ffloor}
Number._eq: {is self}

String.float: {self _builtin.strtof}
String.int: {self _builtin.strtoi}
String.open: {self _builtin.stropen}
String.chars: {self _builtin.strunmk}
// todo: some short form for `dup is X then {pop Y}`?
//       X --> Y? X into Y?
// also some 'match' global? for use in into, switch
// into: {match then {pop Y}}
// X match! Y -> $X Y.match (if ?Y.match)
//            -> $X is $Y   (otherwise)
String.get: {i => self $i $i + 1 dup is 0 then {pop nil} _builtin.strsub}
String.sub: {begin end => self $begin $end _builtin.strsub}
String.find: {o => self $o _builtin.strstr}
String.count: {o => top($o self.split size - 1)}
String.contains: {o => self.find($o) is nil not}
String.escape: {self _builtin.stresc}
String.unescape: {self _builtin.strunesc}
String.quote: {_builtin.strcat('\'' self '\'')}
String.split: {delim => self $delim _builtin.strsplit}
// String.splitws
// String.trim
String.replace: {a b => ($a self.split join! $b)}
String.drop: {n => self $n nil _builtin.strsub}
String.droptail: {n => self 0 $n negate _builtin.strsub}
String.startswith: {s => s.size negate self.droptail is $s}
String.endswith: {s => s.size negate self.drop is $s}
String.upper: {self _builtin.strupper}
String.lower: {self _builtin.strlower}
String.isupper: {self _builtin.strisup}
String.islower: {self _builtin.strislo}
String.size: {self _builtin.strlen}
String.rep: {self _builtin.valstr}
String.str: {self}
String._eq: {is self}

Symbol._eq: {is self}

Closure.apply: {self}
Closure.match: $Closure.apply

list: $_builtin.list
List.open: {self _builtin.lstopen}
List.push: {o => self $o _builtin.lstpush}
List.pop: {self _builtin.lstpop}
List.peek: {self -1 _builtin.lstget}
List.get: {i => self $i _builtin.lstget}
List.set: {i v => self $i $v _builtin.lstset}
List.size: {self _builtin.lstsize}
List.empty: {self _builtin.lstsize is 0}
List.change: {self _builtin.lstchange}
List.append: {size >>n (self _builtin.lstopen dot $n self _builtin.lstchange)}
List.prepend: {self _builtin.lstopen self _builtin.lstchange}
List.shift: {(self _builtin.lstopen size - 1 (dot . self _builtin.lstchange))}
List.unshift: {self.prepend(.)}
List.sub: {begin end => list(self $begin $end _builtin.lstsub)}
List.subopen: {begin end => self $begin $end _builtin.lstsub}
List.insert: {i v => self.change(
    self.subopen(0 $i)
    $v
    self.subopen($i nil)
)}
List.with: {f => self.change(self.open f)}
List.find: {k =>
    i: 0
    top(
        self.open map {$k match swap pop then $i $i + 1 >i}
        nil under
    )
}
List.contains: {v => self.find($v) is nil not}

// todo: move pair elsewhere? ds?
Pair: :{}
pair: {head tail => this as $Pair}
Pair.str: {cat('pair(' $self.head ' ' $self.tail ')')}
Pair.open: {$self.head $self.tail}
Pair.swap: {$self.tail $self.head pair}
Pair.copy: {pair(self.open)}
Pair.clone: {pair(self.open map {.clone})}
Pair.eq: {o => $self.head = $o.head and! {$self.tail = $o.tail}}

extend: { a b =>
    ($b lsv map {s => bindv($a $s $b $s getv)})
}

this >>root

gcs: {_builtin.gccollect _builtin.gcdump}

bench: {
    (
        10 repeat! {profile! {clear(1 to 1000000 fold $add)}}
        fold $add / 10
    )
}
bench10: {10 repeat! $bench}
err: {repeat! {pop}}

// todo: should throw instead take two args?
// throw(#error 'some message')
// throw! #error       (if stack top is symbol, generate message automatically)
throw: { s =>
    $s type = #Symbol then {
        $s switch( $s
            #unbound 'key unbound'
            #underflow 'expected value(s) on stack'
            #type 'expected different type'
            #invalid 'invalid operation'
            #internal 'internal error'
            default {$s str} // todo: get s name without #
        ) _builtin.throw
    } else {
        #error $s _builtin.throw
    }
}
safe: {f => {f true} catch {pop false}}

Reference.str: {
    cat('<reference>')
}
Reference.get: {
    $self.self $self.key getv
}
Reference.set: {
    setv($self.self $self.key .)
}
Reference.bind: {
    bindv($self.self $self.key .)
}
Reference.addlocal: {
    self.get + () self.set
}

argparse: {
    a: :{}
    until {empty or! {dup getp is $Argument not}}
    do {bindv($a . .open)}
    $a
}
Argument.open: {
    $self.key $self.value
}

exit: {0 _builtin.exit}
